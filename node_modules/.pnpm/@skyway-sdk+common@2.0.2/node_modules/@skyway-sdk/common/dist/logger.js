"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.logLevelTypes = void 0;
/**
 * @description [japanese]
 * 以下のいずれかを指定可能
 * - disable: ログの出力を無効化する。
 * - error: 回復不能なエラーに関する情報を出力する。
 * - warn: SDK 内部で発生した、一時的なエラーに関する情報を出力する。基本的には SDK が内部でリトライ処理を行うことで回復する。
 * - info: SDK が提供しているメソッドの呼び出しに関する情報を出力する。
 * - debug: SDK の内部のメソッド呼び出しや、リクエスト・レスポンスに関する情報など、最も詳細なログを出力する。
 */
exports.logLevelTypes = [
    'disable',
    'error',
    'warn',
    'info',
    'debug',
];
class Logger {
    /**@internal */
    constructor(prefix) {
        /**@internal */
        this.debug = (...msg) => {
            this._log('debug', ...msg);
            return Date.now();
        };
        /**@internal */
        this.info = (...msg) => {
            this._log('info', ...msg);
            return Date.now();
        };
        /**@internal */
        this.warn = (...msg) => {
            this._log('warn', ...msg);
        };
        /**@internal */
        this.error = (...msg) => {
            this._log('error', ...msg);
        };
        /**@internal */
        this.elapsed = (timestamp, ...msg) => {
            const elapsed = Date.now() - timestamp;
            this._log('info', `elapsed ms:${elapsed}`, ...msg);
        };
        this.prefix = prefix;
    }
    _log(level, ...msg) {
        const logType = exports.logLevelTypes.indexOf(level);
        const logLevel = exports.logLevelTypes.indexOf(Logger.level);
        const now = new Date();
        const parts = Logger.formatter.formatToParts(now);
        const get = (type) => { var _a; return (_a = parts.find((p) => p.type === type)) === null || _a === void 0 ? void 0 : _a.value; };
        const milliseconds = String(now.getMilliseconds()).padStart(3, '0');
        const timestamp = `${get('year')}-${get('month')}-${get('day')}T${get('hour')}:${get('minute')}:${get('second')}.${milliseconds}+09:00`;
        if (logLevel >= logType) {
            const parsed = [this.prefix, ...msg].map((m) => {
                if (m instanceof Error) {
                    if (m.toJSON) {
                        return m.toJSON();
                    }
                    return { name: m.name, message: m.message, stack: m.stack };
                }
                if (typeof m === 'object') {
                    try {
                        return JSON.parse(JSON.stringify(m));
                    }
                    catch (_a) {
                        return 'json error';
                    }
                }
                return m;
            });
            msg = parsed;
            let log = [timestamp, level, ...msg];
            if (Logger.format === 'string') {
                log = [`${timestamp} ${level} ${JSON.stringify(msg)}`];
            }
            switch (level) {
                case 'debug':
                    console.debug(...log);
                    break;
                case 'info':
                    console.info(...log);
                    break;
                case 'warn':
                    console.warn(...log);
                    break;
                case 'error':
                    console.error(...log);
                    break;
            }
            Logger.onLog({
                id: Logger.id,
                timestamp,
                level,
                message: msg,
            });
        }
        Logger._onLogForAnalytics({
            id: Logger.id,
            timestamp,
            level,
            message: msg,
            prefix: this.prefix,
        });
    }
    /**@internal */
    createBlock(info) {
        return {
            warn: (...msg) => {
                this.warn(Object.assign({}, info), ...msg);
            },
            debug: (...msg) => {
                this.debug(Object.assign({}, info), ...msg);
            },
            info: (...msg) => {
                this.info(Object.assign({}, info), ...msg);
            },
            error: (...msg) => {
                this.error(Object.assign({}, info), ...msg);
            },
        };
    }
}
exports.Logger = Logger;
Logger.level = 'error';
Logger.format = 'object';
Logger.onLog = () => { };
/**@internal */
Logger._onLogForAnalytics = () => { };
/**@internal */
Logger.id = Math.random().toString().slice(2, 7);
Logger.formatter = new Intl.DateTimeFormat('ja-JP', {
    timeZone: 'Asia/Tokyo',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false,
});
//# sourceMappingURL=logger.js.map